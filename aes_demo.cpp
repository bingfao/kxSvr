#include <iostream>
#include <string>
#include <memory>
#include <limits>
#include <stdexcept>

#include <openssl/evp.h>
#include <openssl/rand.h>
#include <iomanip>

static const unsigned int KEY_SIZE = 32;
static const unsigned int BLOCK_SIZE = 16;

typedef unsigned char byte;

using EVP_CIPHER_CTX_free_ptr = std::unique_ptr<EVP_CIPHER_CTX, decltype(&::EVP_CIPHER_CTX_free)>;

void gen_params(byte key[KEY_SIZE], byte iv[BLOCK_SIZE]);
void aes_encrypt(const byte key[KEY_SIZE], const byte iv[BLOCK_SIZE], const std::string &ptext, std::string &ctext);
void aes_decrypt(const byte key[KEY_SIZE], const byte iv[BLOCK_SIZE], const std::string &ctext, std::string &rtext);

// g++ -Wall -std=c++11 evp-encrypt.cxx -o evp-encrypt.exe -lcrypto
int main(int argc, char *argv[])
{
  // Load the necessary cipher
  EVP_add_cipher(EVP_aes_256_cbc());

  // plaintext, ciphertext, recovered text
  std::string ptext = "Now is the time for all good men to come to the aide of their country";
  std::string ctext, rtext;

  byte key[KEY_SIZE], iv[BLOCK_SIZE];
  gen_params(key, iv);
  std::cout << "Key is: " << std::endl;
  for (auto &&byteval : key)
  {
    std::cout << std::setw(2) << std::setfill('0') << std::hex << (short)byteval <<" ";
  }
  std::cout << std::endl;

  std::cout << "IV is: " << std::endl;
  for (auto &&byteval : iv)
  {
    std::cout << std::setw(2) << std::setfill('0') << std::hex << (short)byteval <<" ";
  }
  std::cout << std::endl;

  aes_encrypt(key, iv, ptext, ctext);
  aes_decrypt(key, iv, ctext, rtext);

  OPENSSL_cleanse(key, KEY_SIZE);
  OPENSSL_cleanse(iv, BLOCK_SIZE);

  std::cout << "Original message:\n"
            << ptext << std::endl;
  std::cout << "After AES, is: ";
  for (auto &&byteval : ctext)
  {
    unsigned char v = (unsigned char)byteval;
    std::cout << std::setw(2) << std::setfill('0') << std::hex << (short)v<<" ";
  }
  std::cout << std::dec <<std::endl;
  std::cout << "data length is : " << ctext.length() << std::endl;
  std::cout << "Recovered message:\n"
            << rtext << std::endl;

  return 0;
}

void gen_params(byte key[KEY_SIZE], byte iv[BLOCK_SIZE])
{
  int rc = RAND_bytes(key, KEY_SIZE);
  if (rc != 1)
    throw std::runtime_error("RAND_bytes key failed");

  rc = RAND_bytes(iv, BLOCK_SIZE);
  if (rc != 1)
    throw std::runtime_error("RAND_bytes for iv failed");
}

void aes_encrypt(const byte key[KEY_SIZE], const byte iv[BLOCK_SIZE], const std::string &ptext, std::string &ctext)
{
  EVP_CIPHER_CTX_free_ptr ctx(EVP_CIPHER_CTX_new(), ::EVP_CIPHER_CTX_free);
  int rc = EVP_EncryptInit_ex(ctx.get(), EVP_aes_256_cbc(), NULL, key, iv);
  if (rc != 1)
    throw std::runtime_error("EVP_EncryptInit_ex failed");

  // Recovered text expands upto BLOCK_SIZE
  ctext.resize(ptext.size() + BLOCK_SIZE);
  int out_len1 = (int)ctext.size();

  rc = EVP_EncryptUpdate(ctx.get(), (byte *)&ctext[0], &out_len1, (const byte *)&ptext[0], (int)ptext.size());
  if (rc != 1)
    throw std::runtime_error("EVP_EncryptUpdate failed");

  int out_len2 = (int)ctext.size() - out_len1;
  rc = EVP_EncryptFinal_ex(ctx.get(), (byte *)&ctext[0] + out_len1, &out_len2);
  if (rc != 1)
    throw std::runtime_error("EVP_EncryptFinal_ex failed");

  // Set cipher text size now that we know it
  ctext.resize(out_len1 + out_len2);
}

void aes_decrypt(const byte key[KEY_SIZE], const byte iv[BLOCK_SIZE], const std::string &ctext, std::string &rtext)
{
  EVP_CIPHER_CTX_free_ptr ctx(EVP_CIPHER_CTX_new(), ::EVP_CIPHER_CTX_free);
  int rc = EVP_DecryptInit_ex(ctx.get(), EVP_aes_256_cbc(), NULL, key, iv);
  if (rc != 1)
    throw std::runtime_error("EVP_DecryptInit_ex failed");

  // Recovered text contracts upto BLOCK_SIZE
  rtext.resize(ctext.size());
  int out_len1 = (int)rtext.size();

  rc = EVP_DecryptUpdate(ctx.get(), (byte *)rtext.data(), &out_len1, (const byte *)ctext.data(), (int)ctext.size());
  if (rc != 1)
    throw std::runtime_error("EVP_DecryptUpdate failed");

  int out_len2 = (int)rtext.size() - out_len1;
  rc = EVP_DecryptFinal_ex(ctx.get(), (byte *)&rtext[0] + out_len1, &out_len2);
  if (rc != 1)
    throw std::runtime_error("EVP_DecryptFinal_ex failed");

  // Set recovered text size now that we know it
  rtext.resize(out_len1 + out_len2);
}

//  cl aes_demo.cpp /EHsc /std:c++20 -I "C:\\Program Files\\OpenSSL\\include"  D:\openssl\libcrypto.lib